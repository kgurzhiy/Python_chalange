Должно быть несколько классов с использованием наследования от базового.

У класса должно быть три публичных метода: генерация и получение последовательности, а также новый в требованиях ниже.

Генерация последовательности должна происходить через публичный метод (по аналогу встроенного range, кроме словаря).

Генерацияя словаря, должна работать по аналогу с range, но содержать пары ключ значение: {'1': 1, '2': 2, '3': 3...}, где ключ это текстовый элемент нашего range, а значение - само число. (в предыдущем ДЗ было наоборот!)

Получение последовательности должно браться из файла, если до этого не было сгенерированного файла, то возвращать пустой объект типа каждого класса

Сохранять в файл мы должны полностью сгенерированную последовательность.

Все классы наследники, должны работать с одним файлом! Это значит, что если мы сгенерируем последовательность классом списка, а потом сгенерировать классом словарей, то мы уже не сможем получить сгенерированный список через файл, т.к. сохраненные данные несовместимы. При этом Кортежи, Списки и Множества совместимы - и мы можем получать их.

Конструктор каждого из классов могут принимать один параметр - максимальная длина последовательности, этот аргумент должен ограничивать возможность создания последовательности больше чем он, в противном случае выводить собсвенную ошибку. Этот элемент не должен заменять максимальное значение для метода генерции, а только его ограничивать. По умолчанию элемент равен 100.

Все классы наследники должны работать синхронно, тем самым не блокировать друг другу доступ к файлу.

Если файл отсутсвует, то генерация последовательности должна его создать, прикреплять такой файл не стоит к домашке, но название должно быть - "data.json".

Помимо самой последовательности файл "data.json" должен хранить мета-информацию о данных, а именно:
тип последовательности
количество элементов впоследовательности
тип элементов последовательности
дату создания файла (формат - "30-04-2019 22:53")
дату последнего изменения файла (формат - "30-04-2019 22:53")
авторство записи последовательности (имя класса-генератора)
Минимальный элемент
Максимальний элемент
Если время изменения файла не поменялось - его изменять не стоит.


К новым требованиям я записал основные проблемы с которыми мы стыкались на прошлых ДЗ и у нас повляется возможность сохранять наши данные еще в один файл xml. Файл всегда должен быть один, если сохраняем в xml, то json файл должен удалиться и наоборот.

Также у нас появляется новая генерация последовательности - фибоначчи. Итого наш класс будет иметь три публичных метода - генерация рейнджа, генерация фибоначчи и чтение данных.



Новые требования:

Аналог рейнджа делаем без отрицательного шага.
При генерации последовательности файл должен открываться один раз, проверки на его наличие должны делать через модуль "os".
Данные файла необходимо всегда валидировать.
В случае невалидного формата данных в файла, ловить ошибку.
Добавляем новый параметр в генерацию последовательности - формат файла (json или xml)
Файлы должны называться data.json / data.xml
Файл всегда должен быть один (смотрим и ищем как удалять файлы)
Используем контекстные менеджеры with для работы с файлами.
В мета-данные добавляем новое поле - тип генерации последовательности (range/fibonacci)
Генерация последовательности фибоначчи немного отличается от рейнджа, там будет другой набор аргументов, но метаданные в файле должны быть теми же.